#### This is a project to explore branches
 
 Branch - *При вызове git branch выводятся ветки, которые есть в проекте. Звёздочкой (*) отмечено, в какой ветке вы находитесь в текущий момент<br>

# Branch to Git

 Создать ветку — git branch <название_ветки>

 Переключиться на другую ветку — git checkout <название_ветки>

 Создать ветку и сразу переключиться на неё — git checkout -b <название_ветки>

 Ветка указывает на коммит, который сделан в ней последним. При этом две ветки могут ссылаться на один и тот же коммит — например, если вы только что создали ветку, но ещё не успели внести в неё коммит

 ### Сравниваем ветки
 Чтобы сранить 2 ветки выполни команду git diff "название ветки1" "название ветки2"
 При сравнении вы также можете использовать название ветки и хеш коммита. Для этого сначала выполните команду git log --oneline, чтобы вывести список коммитов.
 Теперь выполните команду git diff с названием основной ветки и хешем коммита в ветке feature/diff. У нас получилась следующая комбинация: git diff main 2ea56ab

 ### Суффикс навигации ~

 Сравнивать хеши комитов может быть неудобно, ведь в одной ветке их может быть много. Представьте: сначала вы выводите историю через git log, затем ищете в длинном списке хеши тех коммитов, которые хотите сравнить, и только потом выполняете git diff.
Для облегчения этой задачи в Git есть суффикс навигации ~N, где N — это число. Он отсчитывает от заданного коммита N коммитов назад во времени. Нумерация начинается с нуля: commit~0 — это сам коммит, commit~1 — предыдущий, commit~2 — предшествующий предыдущему и так далее.
Например, HEAD~1 — это следующий за текущим коммит. А main~5 — это пятый коммит в ветке main, если считать с последнего выполненного коммита.
На практике чаще нужен либо текущий коммит (HEAD), либо следующий за ним (HEAD~1). Для ~1 есть специальное сокращение ~ (без числа). То есть вместо HEAD~1 обычно пишут просто HEAD~
#### Просто что-то написал

